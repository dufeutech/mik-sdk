---
title: OpenAPI Schema Generation
description: Generate OpenAPI 3.0 schemas from your routes at build time
---

import { Aside, Tabs, TabItem, Steps } from "@astrojs/starlight/components";

mik-sdk automatically generates [OpenAPI 3.0](https://spec.openapis.org/oas/v3.0.3) schemas from your `routes!` macro, derive macros, and doc comments. The schema is generated at **test time only** and is never included in the WASM binary.

## Quick Start

<Steps>
1. Define routes with typed inputs and outputs:
   ```rust
   #[derive(Type)]
   pub struct User {
       pub id: String,
       pub name: String,
   }

   /// List all users
   routes! {
       GET "/users" => list_users -> Vec<User>,
   }
   ```

2. Generate the schema:
   ```bash
   cargo test __mik_write_schema -- --nocapture
   ```

3. Find your schema at `openapi.json` in the crate root.
</Steps>

## How It Works

The `routes!` macro generates a hidden `__mik_schema` module containing:

- `json()` - Returns the complete OpenAPI schema as JSON
- `write_to(path)` - Writes the schema to a file

A test named `__mik_write_schema` is also generated that writes the schema to `openapi.json`.

```rust
// Auto-generated by routes! macro (simplified)
#[cfg(not(target_arch = "wasm32"))]
pub mod __mik_schema {
    pub fn json() -> &'static str { /* OpenAPI JSON */ }
    pub fn write_to(path: &Path) -> io::Result<()> { /* write file */ }
}

#[cfg(all(not(target_arch = "wasm32"), test))]
#[test]
fn __mik_write_schema() {
    __mik_schema::write_to(Path::new("openapi.json")).unwrap();
}
```

<Aside type="caution" title="WASM Binary Size">
Schema generation code is **excluded from WASM builds** via `#[cfg(not(target_arch = "wasm32"))]`. This ensures zero overhead in production binaries.
</Aside>

## Generating Schemas

### Single Crate

```bash
# Navigate to your handler crate
cd examples/hello-world

# Generate openapi.json
cargo test __mik_write_schema -- --nocapture

# Output:
# Generated openapi.json (4119 bytes)
```

The schema is written to `openapi.json` in the crate's root directory (where `Cargo.toml` is located).

### Workspace-Wide

Generate schemas for all crates that use the `routes!` macro:

```bash
# From workspace root
cargo test __mik_write_schema --workspace -- --nocapture
```

Each crate with a `routes!` macro will have its own `openapi.json` generated.

### Verify the Schema

```bash
# Pretty-print with jq
cat openapi.json | jq .

# Validate with an OpenAPI linter
npx @redocly/cli lint openapi.json
```

## What's Included in the Schema

The generated schema includes:

| Source | Schema Content |
|--------|---------------|
| `Cargo.toml` | API title (`package.name`) and version (`package.version`) |
| `routes!` paths | Path definitions with methods |
| `#[derive(Type)]` | Request/response body schemas |
| `#[derive(Query)]` | Query parameter definitions |
| `#[derive(Path)]` | Path parameter definitions |
| `/// doc comments` | Operation summaries |
| Path prefixes | Auto-generated tags (e.g., `/users/{id}` â†’ `Users`) |
| Error responses | RFC 7807 ProblemDetails for 4XX/5XX |

## Example Output

Given this handler:

```rust
/// User resource
#[derive(Type)]
pub struct User {
    pub id: String,
    #[field(min = 1, max = 100)]
    pub name: String,
    #[field(format = "email")]
    pub email: Option<String>,
}

#[derive(Query)]
pub struct ListQuery {
    pub search: Option<String>,
    #[field(default = 1)]
    pub page: u32,
    #[field(default = 20, max = 100)]
    pub limit: u32,
}

/// List all users with pagination
routes! {
    GET "/users" => list_users(query: ListQuery) -> Vec<User>,
}
```

The generated schema includes:

```json
{
  "openapi": "3.0.0",
  "info": {
    "title": "my-api",
    "version": "0.1.0"
  },
  "paths": {
    "/users": {
      "get": {
        "tags": ["Users"],
        "summary": "List all users with pagination",
        "parameters": [
          {
            "name": "search",
            "in": "query",
            "required": false,
            "schema": { "type": "string" }
          },
          {
            "name": "page",
            "in": "query",
            "required": false,
            "schema": { "type": "integer", "default": 1 }
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": { "type": "integer", "default": 20, "maximum": 100 }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": { "$ref": "#/components/schemas/User" }
                }
              }
            }
          },
          "4XX": {
            "description": "Client Error",
            "content": {
              "application/problem+json": {
                "schema": { "$ref": "#/components/schemas/ProblemDetails" }
              }
            }
          },
          "5XX": {
            "description": "Server Error",
            "content": {
              "application/problem+json": {
                "schema": { "$ref": "#/components/schemas/ProblemDetails" }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "User": {
        "type": "object",
        "required": ["id", "name"],
        "properties": {
          "id": { "type": "string" },
          "name": { "type": "string", "minLength": 1, "maxLength": 100 },
          "email": { "type": "string", "format": "email", "nullable": true }
        }
      },
      "ProblemDetails": {
        "type": "object",
        "description": "RFC 7807 Problem Details for HTTP APIs",
        "required": ["type", "title", "status"],
        "properties": {
          "type": { "type": "string", "default": "about:blank" },
          "title": { "type": "string" },
          "status": { "type": "integer", "minimum": 100, "maximum": 599 },
          "detail": { "type": "string" },
          "instance": { "type": "string" }
        }
      }
    }
  }
}
```

## Adding Documentation

### Operation Summaries

Add doc comments directly above routes:

```rust
routes! {
    /// List all users with optional search
    GET "/users" => list_users(query: ListQuery),

    /// Create a new user
    POST "/users" => create_user(body: CreateInput),

    /// Get user by ID
    GET "/users/{id}" => get_user(path: Id),
}
```

### Field Descriptions

Use the `docs` attribute on fields:

```rust
#[derive(Type)]
pub struct CreateUserInput {
    #[field(docs = "User's display name", min = 1, max = 100)]
    pub name: String,

    #[field(docs = "Valid email address", format = "email")]
    pub email: String,

    #[field(docs = "Optional profile bio")]
    pub bio: Option<String>,
}
```

## CI Integration

Add schema generation to your CI pipeline:

```yaml
# .github/workflows/ci.yml
- name: Generate OpenAPI schemas
  run: cargo test __mik_write_schema --workspace -- --nocapture

- name: Validate OpenAPI schemas
  run: |
    npm install -g @redocly/cli
    find . -name "openapi.json" -exec redocly lint {} \;

- name: Upload schemas as artifacts
  uses: actions/upload-artifact@v4
  with:
    name: openapi-schemas
    path: "**/openapi.json"
```

## Using the Schema

### Swagger UI / Redoc

Serve your `openapi.json` with documentation tools:

```bash
# Swagger UI
docker run -p 8080:8080 -e SWAGGER_JSON=/schema/openapi.json \
  -v $(pwd)/openapi.json:/schema/openapi.json swaggerapi/swagger-ui

# Redoc
npx @redocly/cli preview-docs openapi.json
```

### Client Generation

Generate typed clients from your schema:

```bash
# TypeScript
npx openapi-typescript openapi.json -o api-types.ts

# Rust
openapi-generator generate -i openapi.json -g rust -o ./client

# Python
openapi-generator generate -i openapi.json -g python -o ./client
```

## Design Philosophy

<Aside type="note" title="Why Test-Time Generation?">
OpenAPI schemas are **documentation artifacts**, not runtime features. By generating at test time:

- **Zero WASM overhead** - No schema strings in production binaries
- **Always up-to-date** - Schema regenerated with each test run
- **Type-safe** - Schema derived from actual Rust types
- **No runtime endpoint** - No `/__schema` route to secure
</Aside>

The schema generation uses [utoipa](https://crates.io/crates/utoipa) internally for type-safe OpenAPI building, ensuring the generated schema is always valid OpenAPI 3.0.

## Troubleshooting

### Schema Not Generated

Ensure your crate has the `routes!` macro:

```rust
routes! {
    GET "/" => home,
}
```

### Missing Types in Schema

Types must use derive macros to appear in the schema:

```rust
#[derive(Type)]   // For request/response bodies
#[derive(Query)]  // For query parameters
#[derive(Path)]   // For path parameters
```

### Test Not Found

The test is only generated when NOT targeting WASM:

```bash
# Correct - native target
cargo test __mik_write_schema

# Wrong - WASM target (test won't exist)
cargo test --target wasm32-wasip2 __mik_write_schema
```

## Next Steps

- [Routing](/guides/routing/) - Define routes with typed inputs
- [Request Reference](/reference/request/) - Access request data
- [Response Reference](/reference/responses/) - Response macros
